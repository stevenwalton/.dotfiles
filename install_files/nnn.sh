#!/usr/bin/env bash
################################################################################
# <INSERT TITLE>
# <INSERT DESCRIPTION>
#
# Author: Steven Walton
# License: MIT
# Contact: dotfiles@walton.mozmail.com
#
# This install script was partially autogenerated. 
# Please verify its output
################################################################################
VERSION=0.0
LOG_FILE="${LOG_DIR:-/tmp/dotfiles_install_nnn.log}"
PREFIX="${PREFIX:-${HOME%/}/.local}"
DL_DIR="${DL_DIR:-/tmp}"
BUILD_DIR="${BUILD_DIR:-${PREFIX%/}/builds}"
#
# Make a link to an official repo
OFFICIAL_REPO="https://github.com/jarun/nnn"
# Default to the official URL but let users override
DL_URL="${DL_URL:-${OFFICIAL_REPO}}"
APP_VERSION="${APP_VERSION:-}" # Leave plant to find latest
PACKAGE_DL_URL="${PACKAGE_DL_URL:-}"

# Allowed extensions to download 
declare -a EXTENSIONS=("tar.gz" "zip")
declare regex # We'll use to parse
declare -a package_list # array of possible packages
declare package # Dummy for our desired package
declare downloaded_extension
declare pkg_name

usage() {
    cat << EOF
<INSERT DESCRIPTION>

[USAGE]
    ...

[OPTIONS]
    -h, --help
        Print this message
    -b, --build-dir
        Directory to build files (default: BUILD_DIR=${PREFIX%/}/builds)
    -t, --target, --prefix
        Location to install to (default: PREFIX=${HOME%/}/.local)
EOF
} # usage


# Find the latest version of the app
find_latest_version() {
    APP_VERSION="$(curl -Ls -o /dev/null -w %{url_effective} "${DL_URL%/}/releases/latest/" | rev | cut -d "/" -f1 | rev)"
    echo $APP_VERSION
} # find_latest_version

# Make the appropraite regex parser given extensions
make_regex() {
    IFS='|' # We want the extensions to be printed as "ext1|...|extn" for regex
    #regex="(.*${PACKAGE_DL_URL}.*>)(.*($(echo "${EXTENSIONS[*]}")))(</a>.*$)"
    regex="(\"browser_download_url\":\s\")(.*)(\"*$)"
    unset IFS
} # make_regex

# This returns the __names__ of packages on the release page
get_package_list() {
    curl_dl_url="${PACKAGE_DL_URL/github.com/api.github.com/repos}"
    curl_dl_url="${curl_dl_url/download/tags}"
    package_list=$(curl -Ls "${curl_dl_url}" | grep -E "${regex}"  | sed -E "s@${regex}@\2@p" | sed 's/"//g' | sed 's/\s//g' | uniq)
} # get_package_list

# Parse the packages for a term
# This replaces  but you can do this in many ways
from_package_list() {
    IFS=$'\n'
    package_list=$(echo "${package_list[*]}" | grep "$1") 
    unset IFS
} # from_package_list

download_package() {
    pkg_name="$(echo ${package_list} | rev | cut -d '/' -f1 | rev)"
    curl -SsJLO --no-clobber "${package_list}" || exit 1
    #     |||||      |_____ Avoids overwriting exiting files, appends dot and number
    #     |||||____________ (--remote-name): Write to local file named like remote file 
    #     ||||_____________ (--location): If server reports another location it'll redirect
    #     |||______________ (--remote-header-name): use server's filename (be careful with Windows!!!)
    #     ||_______________ (--silent): Be quiet. Great for scripts
    #     |________________ (--show-error): If fails, show error. Even when using silent
    # Also helpful
    # --output-dir: writes to a different directory
    # -# / --progress-bar: display a progress bar
    # --remove-on-error: if error, delete file instead of saving
    # -R / --remote-time: Attempt to preserve remote timestamp
    # --retry N: If error, will attempt to retry N times
} # download_package

get_args() {
    while [[ $# -gt 0 ]];
    do
        case "$1" in
            -h | --help)
                usage
                exit 0
                ;;
            -b | --build-dir)
                shift
                BUILD_DIR="$1"
                ;;
            -t | --target | --prefix)
                shift
                PREFIX="$1"
                ;;
            *)
                ;;
        esac
        shift
    done
} # get_args

main() {
    get_args
    if [[ -z $APP_VERSION  ]];
    then
        APP_VERSION=$(find_latest_version)
    fi
    if [[ -z "$PACKAGE_DL_URL" ]];
    then
        PACKAGE_DL_URL="${PACKAGE_DL_URL:-${DL_URL%/}/releases/download/${APP_VERSION}}"
    fi
    make_regex
    get_package_list
    from_package_list "nerd"
    cd ${DL_DIR} && download_package
    echo "Current $PWD"
    cd /home/steven/.local/builds
    echo "Current $PWD"
    mkdir -p nnn && cd nnn
    echo "Current $PWD"
    echo "Will decompress ${DL_DIR%/}/${pkg_name}"
    if [[ "$(echo "$pkg_name" | rev | cut -d "." -f1 | rev)" == "zip" ]];
    then
        unzip "${DL_DIR%/}/${pkg_name}" 
    elif [[ "$(echo "$pkg_name" | rev | cut -d "." -f1-2 | rev)" == "tar.gz" ]];
    then
        tar xzf "${DL_DIR%/}/${pkg_name}" 
    fi
    if [[ $(ls | wc -l) -eq 1 && -x "$(ls)" ]];
    then
        mv "$(ls)" "${PREFIX%/}/bin/nnn"
        cd ..
        mv "${BUILD_DIR}/nnn" /tmp
    else
        echo "We only tested the static binary so probably just need to run make"
    fi

} # main

main "$@" || exit 1
