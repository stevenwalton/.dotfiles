#!/usr/bin/env bash
################################################################################
# Just a small script to create the template for making scripts
# Why retype things when we can generate?
#
# Author: Steven Walton
# License: MIT
# Contact: dotfiles@walton.mozmail.com
################################################################################
AUTHOR="${AUTHOR:-Steven Walton}"
LICENSE="${LICENSE:-MIT}"
CONTACT="${CONTACT:-dotfiles@walton.mozmail.com}"
LOG_DIR="${LOG_DIR:-/tmp}"
LOG_DIR_TEMPLATE="${LOG_DIR_TEMPLATE:-${LOG_DIR%/}/dotfiles_install_programname.log}"
PREFIX="${PREFIX:-${HOME%/}/.local}"
BUILD_DIR="${BUILD_DIR:-${PREFIX%/}/builds}"
#
FIND_OS=
GH_DOWNLOADER=
INCLUDE_ARGS=1
INCLUDE_USAGE=1
PROGRAM_NAME=


homeprefix_substr() {
    if [[ "$1" == ${PREFIX}* && "$1" != ${PREFIX} ]];
    then
        echo '${PREFIX%/}'"${1#${PREFIX}}"
    elif [[ "$1" == ${HOME}* ]];
    then
        echo '${HOME%/}'"${1#${HOME}}"
    else
        echo "$1 :( {}"
    fi
}

make_logfile() {
    echo "${LOG_DIR_TEMPLATE/programname/${PROGRAM_NAME}}"

}
make_template() {
    prefix="$(homeprefix_substr $PREFIX)"
    build_dir="$(homeprefix_substr $BUILD_DIR $prefix)"
    log_file="$(make_logfile)"

    cat << TEMPLATE_END
#!/usr/bin/env bash
################################################################################
# <INSERT TITLE>
# <INSERT DESCRIPTION>
#
# Author: ${AUTHOR}
# License: ${LICENSE}
# Contact: ${CONTACT}
#
# This install script was partially autogenerated. 
# Please verify its output
################################################################################
VERSION=0.0
LOG_FILE="\${LOG_DIR:-${log_file}}"
PREFIX="\${PREFIX:-${prefix}}"
DL_DIR="\${DL_DIR:-/tmp}"
BUILD_DIR="\${BUILD_DIR:-$build_dir}"
TEMPLATE_END
if [[ $GH_DOWNLOADER -eq 1 ]];
then
    cat << TEMPLATE_END
#
# Make a link to an official repo
OFFICIAL_REPO=
# Default to the official URL but let users override
DL_URL="\${DL_URL:-\${OFFICIAL_REPO}}"
APP_VERSION="\${APP_VERSION:-}" # Leave plant to find latest
PACKAGE_DL_URL="\${PACKAGE_DL_URL:-}"

# Allowed extensions to download 
declare -a EXTENSIONS=("tar.gz" "zip")
declare regex # We'll use to parse
declare -a package_list # array of possible packages
declare package # Dummy for our desired package
declare downloaded_extension
declare pkg_name
TEMPLATE_END
else
    cat << TEMPLATE_END
DL_URL=
TEMPLATE_END
fi

if [[ $INCLUDE_USAGE -eq 1 ]];
then
    cat << TEMPLATE_END

usage() {
    cat << EOF
<INSERT DESCRIPTION>

[USAGE]
    ...

[OPTIONS]
    -h, --help
        Print this message
    -b, --build-dir
        Directory to build files (default: BUILD_DIR=${build_dir})
    -t, --target, --prefix
        Location to install to (default: PREFIX=${prefix})
EOF
} # usage
TEMPLATE_END
fi

if [[ $GH_DOWNLOADER -eq 1 ]];
then
    cat << TEMPLATE_END


# Find the latest version of the app
find_latest_version() {
    APP_VERSION="\$(curl -Ls -o /dev/null -w %{url_effective} "\${DL_URL%/}/releases/latest/" | rev | cut -d "/" -f1 | rev)"
    echo \$APP_VERSION
} # find_latest_version

# Make the appropraite regex parser given extensions
make_regex() {
    IFS='|' # We want the extensions to be printed as "ext1|...|extn" for regex
    regex="(.*\${PACKAGE_DL_URL}.*>)(.*(\$(echo "\${EXTENSIONS[*]}")))(</a>.*\$)"
    unset IFS
} # make_regex

# This returns the __names__ of packages on the release page
get_package_list() {
    # Git Release URLs are in the form: https://github.com/foo/bar/releases/1.2.3
    #   So we remove the "download"
    package_list=( \$(curl -s "\${PACKAGE_DL_URL/\/download/}" | grep -E "\${regex}" | sed -E "s@\${regex}@\2@p" | uniq) )
} # get_package_list

# Parse the packages for a term
# This replaces $package_list but you can do this in many ways
from_package_list() {
    IFS=$'\n'
    package_list=\$(echo "\${package_list[*]}" | grep "\$1") 
    unset IFS
} # from_package_list

download_package() {
    pkg_name="\${PACKAGE_DL_URL%}/\${package}"
    downloaded_extension="$(echo \${pkg_name##*.})"
    curl -SsJLO --no-clober "\${pkg_name}"
    #     |||||      |_____ Avoids overwriting exiting files, appends dot and number
    #     |||||____________ (--remote-name): Write to local file named like remote file 
    #     ||||_____________ (--location): If server reports another location it'll redirect
    #     |||______________ (--remote-header-name): use server's filename (be careful with Windows!!!)
    #     ||_______________ (--silent): Be quiet. Great for scripts
    #     |________________ (--show-error): If fails, show error. Even when using silent
    # Also helpful
    # --output-dir: writes to a different directory
    # -# / --progress-bar: display a progress bar
    # --remove-on-error: if error, delete file instead of saving
    # -R / --remote-time: Attempt to preserve remote timestamp
    # --retry N: If error, will attempt to retry N times
} # download_package
TEMPLATE_END
fi

if [[ $INCLUDE_ARGS -eq 1 ]];
then
    cat << TEMPLATE_END

get_args() {
    while [[ \$# -gt 0 ]];
    do
        case "\$1" in
            -h | --help)
                usage
                exit 0
                ;;
            -b | --build-dir)
                shift
                BUILD_DIR="\$1"
                ;;
            -t | --target | --prefix)
                shift
                PREFIX="\$1"
                ;;
            *)
                ;;
        esac
        shift
    done
} # get_args
TEMPLATE_END
fi

    cat << TEMPLATE_END

build_package() {

}

main() {
    get_args
TEMPLATE_END

if [[ $GH_DOWNLOADER -eq 1 ]];
then
    cat << TEMPLATE_END
    if [[ -z $APP_VERSION ]];
    then
        APP_VERSION=\$(find_latest_version)
    fi
    if [[ -z "\$PACKAGE_DL_URL" ]];
    then
        PACKAGE_DL_URL="\${PACKAGE_DL_URL:-\${DL_URL%/}/releases/download/\${APP_VERSION}}"
    fi
    make_regex
    cd $DL_DIR && download_package
    cd $BUILD_DIR
    mkdir -p $PROGRAM_NAME && cd $PROGRAM_NAME
    if [[ "$downloaded_extension" == "zip" ]];
    then
        unzip "\${DL_DIR%/}/\${pkg_name}" 
    elif [[ "$downloaded_extension" == "tar.gz" ]]
    then
        tar xzf "\${DL_DIR%/}/\${pkg_name}" 
    fi

TEMPLATE_END
fi

cat << TEMPLATE_END
    build_package
} # main

main "\$@" || exit 1
TEMPLATE_END
} # End of make_template

usage() {
    cat << EOF
Make a template of a install script.
This won't do everything but it'll save a lot of typing

Normally I'd put a usage here but you should understand this
script before using it, so read it.
EOF
}

get_args() {
    while [[ $# -gt 0 ]];
    do
        case "$1" in
            -h | --help)
                usage
                exit 0
                ;;
            -b | --build-dir)
                shift
                BUILD_DIR="$1"
                ;;
            -t | --target | --prefix)
                shift
                PREFIX="$1"
                ;;
            --program-name)
                shift
                PROGRAM_NAME="$1"
                ;;
            --find-os)
                FIND_OS=1
                ;;
            --github)
                GH_DOWNLOADER=1
                ;;
            --exclude-args)
                INCLUDE_ARGS=0
                ;;
            --exclude-usage)
                INCLUDE_USAGE=0
                ;;
            *)
                ;;
        esac
        shift
    done
}

main() {
    get_args "$@"
    if [[ -z "$PROGRAM_NAME" ]]
    then
        echo "$PROGRAM_NAME"
        echo "Must supply a program name with --program-name <PROGRAM NAME>" && exit 1
    fi
    if [[ -a "${PROGRAM_NAME}.sh" ]];
    then
        read -p "${PROGRAM_NAME}.sh already exists. Overwrite? [y/N]: " -s overwrite
        echo
        case "$overwrite" in
            y | Y | yes | Yes | YES)
                ;;
            *)
                echo -e "\nNot overwriting. Exiting..."
                exit 1
        esac
    fi
    make_template > "${PROGRAM_NAME}.sh"
}

main "$@" || exit 1
