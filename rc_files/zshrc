# This will get called by files we source so place this here
# Just easier to check if commands exist
function _exists() {
    command -v "$1" &> /dev/null
}
DOTFILE_DIR="${HOME}/.dotfiles"
# Load any scripts
#for script in "${DOTFILE_DIR}/scripts/*.sh"; do
#    source "${script}"
#done
# General Exports 
export ZSH_DIR=${HOME}/.dotfiles/rc_files/zsh
export EDITOR="vim"
# Make the path clean
if [[ $(uname) == "Linux" ]]; then
    eval $(cat /etc/environment)
fi
export PATH="${HOME}/.local/bin:${HOME}/.cargo/bin:$PATH"
# Shell like vim
# Keep this up here or the edit-command-line bindkey might mess up
set -o vi
## Lines for autocompletion
source ${ZSH_DIR}/completions.zsh
#
# Enable <C-x><C-e> editing style that bash has
# Credit: https://nuclearsquid.com/writings/edit-long-commands/
# Key this near top. It won't work if sheldon is above this
autoload -U edit-command-line
# Emacs style (<C-x><C-e>)
zle -N edit-command-line
# If not working with vim mode check that `set -o vi` is set above this line
bindkey '^xe' edit-command-line
bindkey '^x^e' edit-command-line
# Vi style (Uses visual to do)
#zle -N edit-command-line
bindkey -M vicmd v edit-command-line

# Sheldon uses TOML files.
# Soft linked: ~/.dotfiles/sheldon_plugins.toml ~/.config/sheldon/plugins.toml
# NOTE: Location sensitive. Check here if things aren't loading
if (_exists sheldon)
then
    eval "$(sheldon source)" 2&>/dev/null
    #source <(sheldon source)
    export PATH="${HOME}/.local/share/sheldon/bin:$PATH"
fi
#export PATH="${HOME}/.local/bin:${HOME}/.cargo/bin:$PATH"

# Bind keys for history substring search
bindkey '^[[A' history-substring-search-up
bindkey '^[[B' history-substring-search-down\

# Uncomment the following line to enable command auto-correction.
# ENABLE_CORRECTION="true"

#####################
# User configuration
#####################
# Starship theme
if (_exists starship)
then
    export STARSHIP_CONFIG="${HOME}/.config/starship.toml"
    eval "$(starship init zsh)"
fi

# You may need to manually set your language environment
# export LANG=en_US.UTF-8
# Don't add to history if prepended with space
setopt HIST_IGNORE_SPACE
HISTFILE=~/.histfile
HISTSIZE=10000
SAVEHIST=10000
setopt appendhistory autocd
#bindkey -v
# Enable history search with up/down keys
autoload -Uz up-line-or-beginning-search down-line-or-beginning-search
zle -N up-line-or-beginning-search
zle -N down-line-or-beginning-search
[[ -n "$key[Up]" ]] && bindkey -- "$key[Up]" up-line-or-beginning-search
[[ -n "$key[Down]" ]] && bindkey -- "$key[Down]" down-line-or-beginning-search

# Fixes tmux window renaming
DISABLE_AUTO_TITLE="true"
# Unset the autonaming for tmux
DISABLE_AUTO_TITLE="true"
# This is not currently working. Looks like this defines the socket and when
# doing this we need to constantly run `tmux -S ~/.local/tmp/my_tmux_socket` to
# do anything. Will determine more later.
#   # Use a local tmux if we have the local temp directory
#   # This can help if we're on a cluster and have different login nodes
#   # Especially when improperly setup. 
#   #if [[ -d "${HOME%/}/.local/tmp" ]];
#   #then
#   #    export TMUX_TMPDIR="${HOME%/}/.local/tmp"
#   #fi


#################################
# Aliases
# load machine specific aliases first as these might depend on /bin commands
#    that we will overwrite
# aliases.zsh has common tools that are not commonly found in /bin
# Then load basic_aliases which has things that will be in /bin. This is because
#    the aliases.zsh may change some /bin commands (like top=htop) and we want 
#    that first
#################################
if [[ $(uname) == "Linux" ]];
then
    source "${ZSH_DIR%/}/linux.zsh"
elif [[ $(uname) == "Darwin" ]];
then
    source "${ZSH_DIR%/}/osx.zsh"
else
    echo "Don't know machine $(uname). No machine specific aliases"
fi
source "${ZSH_DIR%/}/aliases.zsh"
source "${ZSH_DIR%/}/basic_aliases.zsh"

# ssh-eval will create SSH_AUTH_SOCK and SSH_AGENT_PID
# ssh-add needs these two variables to work properly
# So you're probably running this `eval "$(ssh-agent -s)"` command and have a 
# billion ssh-agents running (did you know?)
# Let's handle this a bit better and see if we can create only one and allow us
# to still properly have ssh-add

# If we have neither variables created then you can safely start the ssh-agent 
if [[ ! -v SSH_AUTH_SOCK && ! -v SSH_AGENT_PID ]];
then
    eval "$(ssh-agent -s)" &> /dev/null
elif [[ $(uname) == "Linux" ]];
then
    # If we're on linux there are two ways we can try to find these variables
    # using some a priori knowledge
    # First, the socket should be located at /tmp/ssh-XXXXXX<random>/agent.<PID>
    # Second, we could try to look at each sessions variables.
   
    # Unless we've modified the ssh service, socket files should be created with
    # the format /tmp/ssh-XXXXXX<random alnum>/agent.<PID>
    if [[ $(find /tmp/ssh-XXXXXX* -type s -user $(whoami) -name "agent.*") ]];
    then
        # Get the first socket 
        export SSH_AUTH_SOCK=$(find /tmp/ssh-XXXXXX* -type s -user $(whoami) -name "agent.*" -print -quit)
    else
        for TERMPID in $(ps -e -u $(whoami) | grep -E 'bash|zsh' | awk '{print $1}');
        do
            TMP_AUTH_SOCK=$(/bin/cat /proc/"$TERMPID"/environ | \
                tr '\0' '\n' | \
                grep "SSH_AUTH_SOCK" | \
                awk -F"=" '{print $2}') &> /dev/null
            if [[ $TMP_AUTH_SOCK ]];
            then
                export SSH_AUTH_SOCK="${TMP_AUTH_SOCK}"
            fi
        done
    fi

    if [[ "$SSH_AUTH_SOCK" ]];
    then
        # The auth sock is always named "agent.<PID>"
        export SSH_AGENT_PID=$(echo "${SSH_AUTH_SOCK##*.}")
    else # We never found and existing auth socket
        eval "$(ssh-agent -s)" &> /dev/null
    fi
# elif [[ uname == "Darwin" ]]
# OSX seems to handle this a bit cleaner but I'm still a little confused about
# it. At least for now this appears to be working

# For debugging
#else
#    echo "WARNING: You skipped the whole ssh-agent check"
fi
# Security Note:
# Maybe this leads to security issues but I believe that it would require a user
# to already have permissions where they could already fuck with the socket
# anyways.

# Let's still trap the ssh-agent
function killssh()
{
    kill -9 $SSH_AGENT_PID
}
trap killssh 0


# Spaceduck highlighting
source "${ZSH_DIR%/}/spaceduck.zsh"

. "$HOME/.cargo/env"
